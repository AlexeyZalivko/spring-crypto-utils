#summary Configuration of digital signature signers and verifiers that work with different keys which are mapped by a logical name

= Signer =

{{{
    <crypt:keystore id="mcDonaldsKeystore" location="classpath:keystore-mcdonalds.jks" password="royaleWithCheese"/>
    <crypt:keystore id="burgerKingKeystore" location="classpath:keystore-burger-king.jks" password="r0naldSucksStinkyMeat"/>

    <util:map id="privateKeyMap">
        <entry key="mcDonalds">
            <crypt:privateKey keystore-ref="mcDonaldsKeystore" alias="ronald" password="ketchup"/>
        </entry>
        <entry key="burgerKing">
            <crypt:privateKey keystore-ref="burgerKingKeystore" alias="cowboy" password="meatIsMurder"/>
        </entry>
    </util:map>

    <crypt:signerWithChooserByPrivateKeyId id="signer" privateKeyMap-ref="privateKeyMap" algorithm="SHA1withRSA"/>
}}}

`SHA1withRSA` is the default algorithm and can be omitted.

The signer can then be used like this:

{{{
public class MyBusinessSigner {

    @Autowired
    private SignerWithChooserByPrivateKeyId signer;

    public void myBusinessMethod() {
        byte[] mcsignature = signer.sign("mcDonalds", messageToBeTrusted);
        byte[] bksignature = signer.sign("burgerKing", messageToBeTrusted);
    }
}
}}}

Because you don't usually work directly with byte arrays, but rather with a base64 encoded version of such data, there also is a base64 version of the signer.

{{{
    <crypt:b64SignerWithChooserByPrivateKeyId id="signer" privateKeyMap-ref="privateKeyMap"/>
}}}

Here is an usage example:

{{{
public class MyBase64BusinessSigner {

    @Autowired
    private Base64EncodedSignerWithChooserByPrivateKeyId signer;

    public void myBusinessMethod(String clientName) {
        String b64mcsignature = signer.sign("mcDonalds", "May I have a cheeseburger, please?");
        String b64bksignature = signer.sign("burgerKing", "May I have an hotdog, please?");
    }
}
}}}

= Verifier =

{{{
    <util:map id="publicKeyMap">
        <entry key="mcDonalds">
            <crypt:publicKey keystore-ref="mcDonaldsKeystore" alias="ronald"/>
        </entry>
        <entry key="burgerKing">
            <crypt:publicKey keystore-ref="burgerKingKeystore" alias="cowboy"/>
        </entry>
    </util:map>

    <crypt:verifierWithChooserByPublicKeyId id="verifier" publicKeyMap-ref="publicKeyMap" algorithm="SHA1withRSA"/>
}}} 

Again, `SHA1withRSA` is the default and can be omitted.

Here is an example usage of the verifier:

{{{
public class MyBusinessVerifier {

    @Autowired
    private VerifierWithChooserByPublicKeyId verifier;

    public void myBusinessMethod() {
        // I am not a very useful business method but 
        // I can do digital signatures!
        boolean verified = verifier.verify("mcDonalds", messageToBeTrusted, signature);
    }
}
}}}

The base64 equivalent of the above would be:

{{{
    <crypt:b64VerifierWithChooserByPublicKeyId id="verifier" publicKeyMap-ref="publicKeyMap"/>
}}}

And an example implementation might be:

{{{
public class MyBase64BusinessVerifier {

    @Autowired
    private Base64EncodedVerifierWithChooserByPublicKeyId verifier;

    public void myBusinessMethod(String message, String b64signature) {
        if (verifier.verify("mcDonalds", message, b64signature) {
            proceedWithOrder(message);
        } else {
            // ignore order
        }
    }
}
}}}
